<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    

    const imgs = document.getElementsByClassName('img')
    let count = 0
    function lazyload() {
        for (const img of imgs) {
            if (img.getBoundingClientRect().top < document.documentElement.clientHeight) {
                if (img.getAttribute('src') !== 'default.jpg') continue
                img.src = img.getAttribute('data-src')
                count++
            }
        }
    }
    const observer = new IntersectionObserver((changes) => {
        for (const change of changes) {
            if (change.isIntersecting) {
                const img = change.target
                img.src = img.getAttribute('data-src')
                observer.unobserve(img)
            }
        }
    })
    window.addEventListener('scroll', throttle(lazyload, 200))
    Array.from(imgs).forEach((img) => observer.observe(img))

    function throttle(fn, interval) {
        let flag = true
        return function(...args) {
            const context = this
            if (!flag) return
            flag = false
            setTimeout(() => {
                flag = true
                fn.apply(context, args)
            }, interval)

        }
    }

    function debounce(fn, delay) {
        let timer = null
        let last = 0
        return function(...args) {
            const context = this
            const now = new Date()
            if (now - last < delay) {
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn.apply(context, args)
                    last = now
                }, delay)
            } else {
                fn.apply(context, args)
                last = now
            }
        }
    }

    Function.prototype.bind = function(thisArg, ...args) {
        if (typeof this !== 'function') {
            throw new TypeError('')
        }
        const self = this
        const fbound = function() {
            return self.apply(this instanceof self ? this : thisArg, args.concat(Array.from(arguments)))
        }
        fbound.prototype = Object.create(self.prototype)
        return fbound
    }
    Function.prototype.call = function(thisArg, ...args) {
        const context = thisArg || window
        const fn = Symbol('fn')
        context[fn] = this
        let result = eval(`context[${fn}](...args)`)
        delete context[fn]
        return result
    }
    const canTranvers = new Set([
        '[object Object]',
        '[object Map]',
        '[object Set]',
        '[object Array]',
        '[object Arguments]'
    ])
    const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null
    const getType = (target) => Object.prototype.toString.call(target)
    function handleFunc(target) {
        if (!target.prototype) return target
        const bodyReg = /(?<={)(.|\n)+(?=})/m
        const paramReg = /(?<=\().+(??=\)\s+{)/
        const funcStr = target.toString()
        const param = paramReg.exec(funcStr)
        const body = bodyReg.exec(funcStr)
        if (param) {
            const paramArr = param[0].split(',')
            return new Function(...paramArr, body[0])
        }
        return new Function(body[0])
    }
    function handleNotTraverse(target, type) {
        const ctor = target.constructor
        switch (key) {
            case '[object Boolean]':
                return new Object(Boolean.prototype.valueOf.call(target))
            case '[object Number]':
                return new Object(Number.prototype.valueOf.call(target))
            case '[object String]':
                return new Object(String.prototype.valueOf.call(target))
            case '[object Symbol]': return new Object(Symbol.prototype.valueOf.call(target))
            case '[object Date]':
            case '[object Error]':
                return new ctor()
            case '[object Regexp]':
                const { source, flags } = target
                return new ctor(source, flags)
            case '[object Function]':
                return handleFunc(target)
        
            default:
                return new ctor()
        }

    }
    function deepClone(target, map = new WeakMap()) {
        if (!isObject(target)) return target
        const type = getType(target)
        let cloneTarget
        if (canTranvers.has(type)) {
            const ctor = target.constructor
            cloneTarget = new ctor()
        } else {
            return handleNotTraverse(target, type)
        }
        if (map.get(target)) {
            return target
        }
        map.set(target, true)
        if (type === '[object Map]') {
            target.forEach((item, key) => {
                cloneTarget.set(deepClone(key, map), deepClone(item, map))
            })
        }
        if (type === '[object Set]') {
            target.forEach((item) => {
                cloneTarget.add(deepClone(item, map))
            })
        }
        for (const prop of target) {
            if (target.hasOwnProperty(prop)) {
                cloneTarget[prop] = deepClone(target[prop], map)
            }
        }
        return cloneTarget
    }
    function bubbleSort(arr) {
        let len = arr.length
        let newLen = 0
        do {
            newLen = 0
            for (let i = 1; i < len; i++) {
                if (arr[i-1] > arr[i]) {
                    const temp = arr[i]
                    arr[i] = arr[i-1]
                    arr[i-1] = temp
                    newLen = i
                }
            }
            len = newLen
        } while (len > 0)
    }
</script>

</html>